# { dg-options "-fstropping=upper" }  #
# Union with VOID #
BEGIN OP TOPROCINT = (INT i) PROC INT : INT : 1;
      OP TOVOID = (INT i) VOID : 1;

      STRING proc int = "proc int", void = "void",
             before = "before ", after = " after",
             newline = "\n";

      puts ("Results must be:" + newline +
            void + newline +
            proc int + after + " 1 " + newline +
            before +  void + newline +
            before + void + newline +
            before + void + newline +
            proc int + " 1 " + newline +
            void + newline +
            proc int + " 1 " + newline +
            proc int + after + " 1 " + newline +
            before + void + newline + 
            newline + "Results are:" + newline);

      UNION(PROC INT, VOID) upiv := EMPTY;
      PROC pupiv = VOID:
         (upiv
             |(PROC INT pi) : (puts (proc int + " pi " + newline))
             | puts (void + newline));

      pupiv;
      upiv:= INT : (puts(after); 1);
      pupiv;

      upiv:= VOID : (puts(before); 1);
      pupiv;

      upiv:= VOID ((puts(before); 1));
      pupiv;

      # firm void position #
      upiv:= puts(before);
      pupiv;

      upiv:= TOPROCINT 1;
      pupiv;

      upiv:= TOVOID 1;
      pupiv;

      upiv:= INT : 1;
      upiv:= label # must jump before assigning #; puts("Error 1");
label:
      pupiv;

      FOR i TO 2
      DO upiv:=
            CASE i IN
               INT : (puts(after); 1),
               VOID : (puts(before); 1)
            ESAC;
         pupiv
      OD
END
