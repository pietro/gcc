# { dg-options "-fstropping=upper" }  #
# Simple coercions.  #
BEGIN [1:3]INT ia := (1, 2, 3);
      PROC get ia = REF[]INT: ia;
      # Dereferencing.  #
      INT i := LOC REF INT := ia[1]; # Twice dereferenced, at the right moment.  #
      ASSERT (i = 1);
      REF INT ri := ia[2]; # No deref  #
      REF INT (ri) := -2;
      ASSERT (ia[1] = 1 AND ia[2] = -2 AND ia[3] = 3);
      # Deproceduring.  #
      PROC pri = REF INT: ia[3]; pri := -3; # Soft deproc.  #
      ASSERT (ia[1] = 1 AND ia[2] = -2 AND ia[3] = -3);
      PROC pria = REF[]INT: ia; pria[1] := pria[2];
      ASSERT (ia[1] = -2 AND ia[2] = -2 AND ia[3] = -3);
      # Uniting.  #
      UNION(REAL,[]INT,[,]INT) unia = # some uniting  #
         UNION(REAL,[]INT) # cast  # # one uniting  # (ia); # deref  #
      ia := (3,2,1); # spoil ia  #
      CASE unia
      IN ([]INT ia): (ASSERT (ia[1] = -2 AND ia[2] = -2 AND ia[3] = -3);
                      ASSERT (get ia[1] = 3 AND get ia[2] = 2 AND get ia[3] = 1))
      OUT SKIP
      ESAC;
      # Widening.  #
      REAL x = ia[1];
      ASSERT (x > 2.9 AND x < 3.1);
      # Rowing.  #
      [1:1,1:3] INT iaa; FOR i TO 3 DO iaa[1,i] := 5 + i OD;
      # Hipping.  #
      REF INT p = NIL, q = NIL;
      ASSERT (p :=: q);
      ia := (5, SKIP, 7); ia[2] := 6;
      ASSERT (ia[1] = 5 AND ia[2] = 6 AND ia[3] = 7)
END
