# { dg-options "-fstropping=upper" }  #

BEGIN # 1. Actual declaration.  #
      # 1.a Without bounds.  #

      # primitive  #
      BEGIN INT x1,
            INT x2, x3,
            INT x4, x5, x6,
            REAL x7, x8, x9, x10, x11, x12,
            LONG INT x13,
            LONG REAL x14,
            BOOL x15,
            CHAR x16;
            SKIP
      END;

      # ref + primitive  #
      BEGIN REF INT x1,
            REF REF REF REAL x2,
            REF REF REF REF LONG REAL x3,
            REF REF REF REF REF BOOL x4,
            REF REF REF REF REF REF CHAR x5,
            REF REF PROC VOID x6;
            SKIP
      END;

      # proc  #
      BEGIN PROC VOID x1,
            PROC PROC REAL x2,
            PROC PROC PROC PROC LONG REAL x3,
            PROC PROC PROC PROC PROC BOOL x4,
            PROC PROC PROC PROC PROC PROC CHAR x5,
            PROC PROC PROC VOID x6;
            SKIP
      END;

      # ref + proc  #
      BEGIN REF REF REF REF REF REF PROC VOID x1,
            PROC REF REAL x2,
            PROC REF PROC REF LONG REAL x3,
            PROC REF PROC REF PROC BOOL x4,
            REF PROC REF PROC REF PROC CHAR x5,
            PROC REF PROC VOID x6;
            SKIP
      END;

      # proc with one parameter which is primitive or ref + primitive  #
      BEGIN PROC(INT)VOID x1,
            PROC(REF REF REF LONG INT)VOID x2,
            PROC(BOOL)VOID x3,
            PROC(REF CHAR)VOID x4,
            PROC(LONG REAL)VOID x5,
            PROC(REF REF REF BOOL)VOID x6,
            PROC(PROC VOID)VOID x7,
            PROC(REF REF PROC VOID)VOID x8;
            SKIP
      END;

      # ref + proc with one parameter which is primitive or ref + primitive  #
      BEGIN REF PROC(INT)VOID x1,
            REF REF PROC(LONG REAL)VOID x2, x3,
            REF REF REF REF PROC(REF CHAR)VOID x4,
            REF PROC(PROC VOID)VOID x5,
            REF REF PROC(REF PROC VOID)VOID x6;
            SKIP
      END;

      # ref * proc with more than one parameter which are ref * primitive  #
      BEGIN PROC(INT,LONG INT)VOID x1,
            PROC(REAL,REF LONG REAL,REF REF BOOL)VOID x2,
            PROC(REF REF REF CHAR,INT,LONG INT,REAL,REAL,INT)VOID x3,
            REF PROC(INT,INT,INT,REF CHAR)VOID x4,
            REF REF REF PROC(PROC VOID,REF REF PROC VOID,INT)VOID x5;
            SKIP
      END;

      # ref + row of * ref * primitive  #
      BEGIN REF[]INT x1,
            REF[,]REAL x2,
            REF REF[,,,]LONG REAL x3,
            REF REF REF[,,,,,]REF BOOL x4,
            REF[]REF REF REF LONG INT x5,
            REF REF[,,,,]REF REF CHAR x6,
            REF[]PROC VOID x7,
            REF[,]REF REF PROC VOID x8;
            SKIP
      END;

      # ref + row of * ref * proc  #
      BEGIN REF[] PROC VOID x1,
            REF REF[,] PROC(REF INT)VOID x2,
            REF REF REF[]PROC(INT, REF REF INT)VOID x3,
            REF[]REF PROC(REF LONG REAL, REF REF REF CHAR, REF LONG LONG REAL)VOID x4,
            REF REF[,,,]REF REF REF PROC(REF INT, LONG LONG LONG INT)VOID x5;
            REF[]PROC(PROC VOID,REF PROC VOID)VOID x6;
            SKIP
      END;

      # ref * proc with row of parameters  #
      BEGIN PROC([]REAL)VOID x1,
            REF PROC(INT, []LONG REAL)VOID x2,
            REF REF PROC([,]INT, []REF REF BOOL)VOID x3,
            REF REF REF REF PROC(REF[]INT, REF REF[]REF REF LONG REAL)VOID x4,
            PROC(REF REF[,,,]REF REF REF REAL)VOID x5,
            PROC([]REF REAL, [,,,]REF CHAR, REF[,]BOOL)VOID x6,
            PROC([]REF PROC VOID, REF[,,]PROC VOID, REF REF[,]REF REF PROC VOID)VOID x7;
            SKIP
      END;

      # nested rows  #
      BEGIN REF[,,,]REF[,]INT x1,
            REF[]REF[]PROC VOID x2,
            REF[]REF REF[]REF BOOL x3,
            REF[,,,]REF[,,,]REF REF REF PROC VOID x4,
            REF REF[]REF[]INT x5,
            REF[]REF[]REF[]REF[]REF[]LONG REAL x6;
            SKIP
      END;

      # nested procs  #
      BEGIN PROC(PROC(PROC (PROC VOID)VOID)VOID)VOID x1,
            PROC(INT,
                 PROC(REF REF PROC VOID,
                      REAL,
                      REF PROC(REF LONG INT, PROC VOID)VOID,
                      INT) VOID)VOID x2,
            PROC(INT,
                 PROC VOID,
                 PROC (INT,
                       PROC VOID,
                       REF REAL,
                       REF PROC VOID)VOID)VOID x3,
            PROC(INT,
                 PROC (INT,INT) VOID,
                 PROC (INT) VOID,
                 REAL)VOID x4;
            SKIP
      END;

      # mixed rows and procs  #
      BEGIN REF[]PROC([,]INT,PROC([]PROC VOID) VOID,
                      [,] PROC(PROC VOID, INT) VOID,
                      REF[]PROC VOID)VOID x1;
            SKIP
      END;

      # 1.b. With bounds.  #
      BEGIN [1:1]INT x1,
            [1:1,1:1]REF LONG REAL x2,
            [1:1,1:1,1:1]REF REF PROC VOID x3,
            [1:1]PROC VOID x4,
            [1:1]PROC(INT)VOID x5,
            [1:1]PROC(INT,REAL,REF PROC VOID)VOID x6,
            [1:1,1:1,1:1,1:1]REF REF PROC(INT)VOID x7,
            [1:1]REF[]INT x8,
            [1:1]REF[,,,]REF PROC VOID x9,
            [1:1]REF PROC([]INT)VOID x10,
            [1:1]PROC([]REF PROC VOID, REF[,,]PROC VOID,
                      REF REF REF REF[,]REF REF REF PROC VOID)VOID x11,
            [1:1]REF[]REF[,,]REF REF[]LONG REAL x12,
            [1:1]PROC(REF[]PROC VOID, []PROC VOID, []REF INT)VOID x13;
            SKIP
      END;

      # 2. Variable and constant declarations.  #

      BEGIN PROC VOID a; PROC(INT)VOID b;
            PROC VOID c, d; REAL e; REAL f, g;
            SKIP; SKIP; SKIP; SKIP
      END;

      # 3. Declarations of routines.  #

      BEGIN INT i;
            PROC a = VOID: SKIP;
            PROC(INT)VOID b = (INT c) VOID: SKIP;
            PROC(INT,REAL)VOID c = (INT e, REAL f) VOID: SKIP;
            BEGIN PROC c = VOID: a; # no error  # SKIP END
      END;

      # 4. Call without parameters.  #

      BEGIN PROC VOID a = VOID: SKIP;
            PROC VOID b := a;
            REF PROC VOID c := b;
            REF REF PROC VOID d = c;

            a; # without deref  #
            b; # with deref  #
            c; # with deref  #
            d; # with deref  #

            SKIP
      END;

      # 5. Call with parameters.  #
      BEGIN INT int; REAL real;
            PROC(INT)VOID dcs1,
            PROC(INT,REAL)VOID dcs2;
            PROC(INT)VOID a = (INT a) VOID: SKIP;
            PROC(INT)VOID b;
            REF PROC(INT)VOID c = b;
            REF PROC(INT)VOID d;
            PROC(INT,REAL)VOID e = (INT a, REAL b) VOID: SKIP;

            a (int);
            dcs1 (int);
            dcs2 (int, real);
            e (int, real);
            b (int);
            c (int);
            d (int);
            BEGIN REF REF REF REF REF REF REF REF REF REF
                  REF REF REF REF REF REF REF REF REF REF
                  PROC(INT)VOID a; a (int); SKIP
            END;
            BEGIN # No error  #
               PROC(REF INT, REF REAL)VOID a;
               a (int, real)
            END;

            BEGIN PROC(INT)VOID a; a (int) END;
            BEGIN PROC(INT)VOID a; a (int); SKIP END
      END;

      # 6. Assignation with an identifier as destination.  #

      BEGIN INT a; REF INT b = a; PROC(REAL)REAL c;
            a := 1;
            b := a;
         CO   c := sin; XXX CO
            SKIP
      END;

      # 7. Assignation with a slice as destination.  #

      BEGIN INT i, j, k, l;
            [i:i]REAL a1;
            [i:i,j:j]REAL a2;
            REF[]REAL a3 = a1;
            REF[,]REAL a4;
            REF[,,]REAL a5 = a4;
            [,,,]REF REAL a6 = a3[i];

            a1[i] := 3;
            a2[i,j] := 3;
            a3[i] := 3;
            a4[i,j] := 3;
            a5[i,j,k] := 3;
            a6[i,j,k,l] := 3;
            BEGIN REF REF REF REF REF REF REF REF REF REF
                  REF REF REF REF REF REF REF REF REF REF
                  []REAL x;
                  x[i] := 3.0
            END
      END
END
